30 constant n
10000 constant frames

variable neighbours 
variable alivecells
variable deadcells

n n * allocate drop constant A1
n n * allocate drop constant A2
n n * allocate drop constant B1
n n * allocate drop constant B2
frames 1 + 4 * allocate drop constant livecells

CREATE SEED  123445629 ,

: Rnd ( n -- rnd )   
   SEED              
   DUP >R            
   @ 127773 /MOD 
   2836 * SWAP 16807 * 
   2DUP > IF - 
   ELSE - 2147483647 +  
   THEN  DUP R> !
   SWAP MOD ;

: rnd10 10 rnd 
	0 <= if 1 
	else 0 
	then ;

: reset10 n n * 0 do dup rnd10 swap I + C! loop drop ;

: rnd20 10 rnd 
	1 <= if 1 
	else 0 
	then ;

: reset20 n n * 0 do dup rnd20 swap I + C! loop drop ;

: rnd30 10 rnd 
	2 <= if 1 
	else 0 
	then ;

: reset30 n n * 0 do dup rnd30 swap I + C! loop drop ;

: rnd40 10 rnd 
	3 <= if 1 
	else 0 
	then ;

: reset40 n n * 0 do dup rnd40 swap I + C! loop drop ;

: rnd60 10 rnd 
	5 <= if 1 
	else 0 
	then ;

: reset60 n n * 0 do dup rnd60 swap I + C! loop drop ;

: rnd70 10 rnd 
	6 <= if 1 
	else 0 
	then ;

: reset70 n n * 0 do dup rnd70 swap I + C! loop drop ;

: rnd80 10 rnd 
	7 <= if 1 
	else 0 
	then ;

: reset80 n n * 0 do dup rnd80 swap I + C! loop drop ;

: rnd90 10 rnd 
	8 <= if 1 
	else 0 
	then ;

: reset90 n n * 0 do dup rnd90 swap I + C! loop drop ;





: myloop 0 do rnd40 loop ;

: makerandom01 256 0 do 2 rnd loop ;

: add_small_array 255 0 do dup I + c@ loop drop ;





: counts swap
	n n * 0 do 0 neighbours !

		I n mod 0= if   	3 neighbours ! else
		I 1 + n mod 0= if 	3 neighbours ! else
		I n <= if		3 neighbours ! else
		I n n * n - >= if       3 neighbours ! else 


		dup I + n - 1 - c@ neighbours @ + neighbours !  	
		dup I + n - c@ neighbours @ + neighbours !		
		dup I + n - 1 + c@ neighbours @ + neighbours !		
		dup I + 1 - c@ neighbours @ + neighbours !		
		dup I + 1 + c@ neighbours @ + neighbours !		
		dup I + n + 1 - c@ neighbours @ + neighbours !		
		dup I + n + c@ neighbours @ + neighbours !		
		dup I + n + 1 + c@ neighbours @ + neighbours !		
		
		then then then then


		swap dup I + neighbours @ swap C! swap 0 neighbours ! loop drop drop ;





: decide rot rot n n * 0 do dup I + c@
			case
			0 of 0 3 pick I + c! endof
			1 of 0 3 pick I + c! endof

			3 of 1 3 pick I + c! endof

			4 of 0 3 pick I + c! endof
			5 of 0 3 pick I + c! endof
			6 of 0 3 pick I + c! endof
			7 of 0 3 pick I + c! endof
			8 of 0 3 pick I + c! endof
			9 of 0 3 pick I + c! endof
			
			2 of 1 pick I + c@ 3 pick I + c! endof
			endcase
			loop drop drop drop ;




: array_! rot rot 1 - swap 1 - swap n * + + C! ;

: array_@ rot rot 1 - swap 1 - swap n * + + C@ ;

: reset0 n n * 0 fill ;

: resetlivecells livecells frames 0 fill ;

: reset1 n n * 1 fill ;

: reset01 n n * 0 do dup 2 rnd swap I + C! loop drop ;

: SSA cr n 0 do n 0 do dup J n * I + + c@ 2 .R loop cr loop drop ;

: linear_small_array n n * 1 do dup I + I swap C! loop drop ;

: clear depth 0 do drop loop ;



 
: next 1 pick b1 counts b1 swap decide ;

: next1 dup dup b1 counts b1 swap decide ;

: ssa2 cr n 0 do n 0 do dup J n * I + + c@ 
	case 
	 0 of ." - " endof
	 1 of ." X " endof
	endcase
	loop cr loop drop ;

: nextprint dup next1 ssa2 ;

: simulate dup cr ." Starting grid : " cr ssa2 1 pick 0 do dup ." Frame " I 1+ . nextprint loop drop drop ;

: skip 1 pick 0 do dup next1 loop drop drop ;



: Random-bmp-Blue  ( addr -- )            { Set bmp starting at addr to random blue pixels }
  dup dup 2 + @ + swap 54 + dup rot rot do
  dup I swap - 3 / a1 + c@ 255 *      	  { Red   RGB value                                }
  dup				  	  { Green RGB value                                }
  dup 					  { Blue  RGB value                                }
  i  tuck c!
  1+ tuck c!
  1+      c!      
  3 +loop
  ;


: go-stretch                          { Draw bmp to screen at variable pixel size       }
  cr ." Starting looped stretch to window test " 
  cr cr
  New-bmp-Window-stretch              { Create new "stretch" window                     }
  bmp-window-handle !                 { Store window handle                             }
  Begin	                              { Begin update / display loop                     }
  bmp-address @ Random-bmp-Blue       { Add random pixels to .bmp in memory             }
  bmp-address @ bmp-to-screen-stretch { Stretch .bmp to display window                  }
  100 ms                              { Delay for viewing ease, reduce for higher speed }
  key?                                { Break test loop on key press                    }
  until
  cr ." Ending looped
 stretch to window test " 
  cr cr
  ;

: skipto skip go-stretch ;


: countcells 0 alivecells ! 0 deadcells ! 
	cr n 0 do n 0 do dup J n * I + + c@ 
	case 
	 0 of deadcells @ 1 + deadcells ! endof
	 1 of alivecells @ 1 + alivecells ! endof
	endcase
	loop loop drop 
	alivecells @
	." There are " alivecells @ . ." alive cells " cr
	." There are " deadcells @ . ." dead cells " ;

: countcell 0 alivecells ! 0 deadcells ! 
	n 0 do n 0 do dup J n * I + + c@ 
	case 
	 0 of deadcells @ 1 + deadcells ! endof
	 1 of alivecells @ 1 + alivecells ! endof
	endcase
	loop loop drop 
	alivecells @ ;

: skipcount dup rot rot skip countcell ;

: runcount resetlivecells 
	dup countcell livecells ! 
	frames 1 + 1 do 
	dup 1 swap skipcount livecells I 4 * + ! loop drop ;

: printdata cr frames 1 + 0 do dup I 4 * + @ . cr loop drop ;


: savedata cr frames 1 + 0 do dup I 4 * + @ (.) test-file-id @ write-line drop loop ;

: go0 
  make-test-file
  test-file-size cr cr ." File Start Size = " d.   
  savedata
  test-file-size cr cr ." File End Size =   " d. cr cr
  close-test-file
  drop   ;






