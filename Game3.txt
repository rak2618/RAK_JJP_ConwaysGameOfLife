20 constant n
1000 constant frames

variable neighbours 
variable alivecells
variable deadcells

n n * allocate drop constant A1
n n * allocate drop constant A2
n n * allocate drop constant B1
n n * allocate drop constant B2
frames 1 + 4 * allocate drop constant livecells

CREATE SEED  111111111 ,

: Rnd ( n -- rnd )   
   SEED              
   DUP >R            
   @ 127773 /MOD 
   2836 * SWAP 16807 * 
   2DUP > IF - 
   ELSE - 2147483647 +  
   THEN  DUP R> !
   SWAP MOD ;





: myloop 0 do rnd40 loop ;

: makerandom01 256 0 do 2 rnd loop ;

: add_small_array 255 0 do dup I + c@ loop drop ;




: counts swap
	n n * 0 do 0 neighbours !
		
		
		I n mod 0= if 	
				I 0= if dup I + 1 + c@ neighbours @ + neighbours !		
					dup I + n + c@ neighbours @ + neighbours !		
					dup I + n + 1 + c@ neighbours @ + neighbours ! 
				else 
				I n 1 - n * = if dup I + n - c@ neighbours @ + neighbours !		
					  	 dup I + n - 1 + c@ neighbours @ + neighbours !		
					  	 dup I + 1 + c@ neighbours @ + neighbours !

				else
				dup I + n - c@ neighbours @ + neighbours !		
				dup I + n - 1 + c@ neighbours @ + neighbours !		
				dup I + 1 + c@ neighbours @ + neighbours !		
				dup I + n + c@ neighbours @ + neighbours !		
				dup I + n + 1 + c@ neighbours @ + neighbours !	then then
 			else



		I 1 + n mod 0= if 	
				I n 1 - = if dup I + 1 - c@ neighbours @ + neighbours !		
					  dup I + n + 1 - c@ neighbours @ + neighbours !		
					  dup I + n + c@ neighbours @ + neighbours ! 
				else 
				I n n * 1 - = if dup I + n - 1 - c@ neighbours @ + neighbours !		
					  dup I + n - c@ neighbours @ + neighbours !		
					  dup I + 1 - c@ neighbours @ + neighbours !

					else
					dup I + n - 1 - c@ neighbours @ + neighbours !  	
					dup I + n - c@ neighbours @ + neighbours !		
					dup I + 1 - c@ neighbours @ + neighbours !		
					dup I + n + 1 - c@ neighbours @ + neighbours !		
					dup I + n + c@ neighbours @ + neighbours ! then then		
 			else

		I n <= if 	dup I + 1 - c@ neighbours @ + neighbours !		
		 		dup I + 1 + c@ neighbours @ + neighbours !		
				dup I + n + 1 - c@ neighbours @ + neighbours !		
				dup I + n + c@ neighbours @ + neighbours !		
				dup I + n + 1 + c@ neighbours @ + neighbours !		
			else

		I n n * n - >= if 	dup I + n - 1 - c@ neighbours @ + neighbours !  	
				dup I + n - c@ neighbours @ + neighbours !		
				dup I + n - 1 + c@ neighbours @ + neighbours !		
				dup I + 1 - c@ neighbours @ + neighbours !		
				dup I + 1 + c@ neighbours @ + neighbours !		

			else
		

		dup I + n - 1 - c@ neighbours @ + neighbours !  	
		dup I + n - c@ neighbours @ + neighbours !		
		dup I + n - 1 + c@ neighbours @ + neighbours !		
		dup I + 1 - c@ neighbours @ + neighbours !		
		dup I + 1 + c@ neighbours @ + neighbours !		
		dup I + n + 1 - c@ neighbours @ + neighbours !		
		dup I + n + c@ neighbours @ + neighbours !		
		dup I + n + 1 + c@ neighbours @ + neighbours !		
		
		then then then then

		swap dup I + neighbours @ swap C! swap 0 neighbours ! loop drop drop ;



: decide rot rot n n * 0 do dup I + c@
			case
			
			
			2 of 1 pick I + c@ 
				case 
				0 of 0 endof
				1 of 1 endof
				endcase
				endof

			0 of 0 endof
			1 of 0 endof
			3 of 1 endof

			4 of 1 endof
			5 of 0 endof
			6 of 0 endof
			7 of 0 endof
			8 of 0 endof
			9 of 0 endof

			endcase
			
			3 pick I + c!
			
			loop drop drop drop ;




: array_! rot rot 1 - swap 1 - swap n * + + C! ;

: array_@ rot rot 1 - swap 1 - swap n * + + C@ ;

: reset0 n n * 0 fill ;

: resetlivecells livecells frames 0 fill ;

: reset1 n n * 1 fill ;

: reset01 n n * 0 do dup 2 rnd swap I + C! loop drop ;

: SSA cr n 0 do n 0 do dup J n * I + + c@ 2 .R loop cr loop drop ;

: linear_small_array n n * 1 do dup I + I swap C! loop drop ;

: clear depth 0 do drop loop ;



 
: next 1 pick b1 counts b1 swap decide ;

: next1 dup dup b1 counts b1 swap decide ;

: ssa2 cr n 0 do n 0 do dup J n * I + + c@ 
	case 
	 0 of ." - " endof
	 1 of ." X " endof
	endcase
	loop cr loop drop ;

: nextprint dup next1 ssa2 ;

: simulate dup cr ." Starting grid : " cr ssa2 1 pick 0 do dup ." Frame " I 1+ . nextprint loop drop drop ;

: skip 1 pick 0 do dup next1 loop drop drop ;



: Random-bmp-Blue  ( addr -- )            { Set bmp starting at addr to random blue pixels }
  dup dup 2 + @ + swap 54 + dup rot rot do
  dup I swap - 3 / a1 + c@ 255 *      	  { Red   RGB value                                }
  dup				  	  { Green RGB value                                }
  dup 					  { Blue  RGB value                                }
  i  tuck c!
  1+ tuck c!
  1+      c!      
  3 +loop
  ;


: go-stretch                          { Draw bmp to screen at variable pixel size       }
  cr ." Starting looped stretch to window test " 
  cr cr
  New-bmp-Window-stretch              { Create new "stretch" window                     }
  bmp-window-handle !                 { Store window handle                             }
  Begin	                              { Begin update / display loop                     }
  bmp-address @ Random-bmp-Blue       { Add random pixels to .bmp in memory             }
  bmp-address @ bmp-to-screen-stretch { Stretch .bmp to display window                  }
  100 ms                              { Delay for viewing ease, reduce for higher speed }
  key?                                { Break test loop on key press                    }
  until
  cr ." Ending looped
 stretch to window test " 
  cr cr
  ;

: skipto skip go-stretch ;
: skipt skip ssa2 ;

: countcells 0 alivecells ! 0 deadcells ! 
	cr n 0 do n 0 do dup J n * I + + c@ 
	case 
	 0 of deadcells @ 1 + deadcells ! endof
	 1 of alivecells @ 1 + alivecells ! endof
	endcase
	loop loop drop 
	alivecells @
	." There are " alivecells @ . ." alive cells " cr
	." There are " deadcells @ . ." dead cells " ;

: countcell 0 alivecells ! 0 deadcells ! 
	n 0 do n 0 do dup J n * I + + c@ 
	case 
	 0 of deadcells @ 1 + deadcells ! endof
	 1 of alivecells @ 1 + alivecells ! endof
	endcase
	loop loop drop 
	alivecells @ ;

: skipcount dup rot rot skip countcell ;

: runcount resetlivecells 
	dup countcell livecells ! 
	frames 1 + 1 do 
	dup 1 swap skipcount livecells I 4 * + ! loop drop ;

: printdata cr frames 1 + 0 do dup I 4 * + @ . cr loop drop ;


: savedata cr frames 1 + 0 do dup I 4 * + @ (.) test-file-id @ write-line drop loop ;

: go0 
  make-test-file
  test-file-size cr cr ." File Start Size = " d.   
  savedata
  test-file-size cr cr ." File End Size =   " d. cr cr
  close-test-file
  drop   ;






